     When creating this parser, we discovered that our grammar was not LL(k).  Our old grammar was technically LL(infinity). This was because a Func in our grammar could turn into a FuncName followed by an ArgList or a Branch.  Since Branch started with a FuncName, both options became the same non-terminal.  Since it is possible to nest function calls to an arbitrary depth in our language, there was no amount of lookahead after which the parser would know whether it was processing a Branch or a FuncName followed by an ArgList.  Our grammar had to be adjusted in order to make it at most LL(1 or 2), so all Branches are now preceded by a semicolon to allow the parser to differentiate between the two cases.
     One unsolved problem with our Parser is that it does not display tokens that are expected when a program fails to parse correctly. The parser can tell you that there was an invalid Token and tell you what the invalid token was, but it doesnâ€™t know which token(s) should be there. For example, given the code (identifier], the parser would tell you that ] is invalid, but it would not suggest that a ) was missing.
