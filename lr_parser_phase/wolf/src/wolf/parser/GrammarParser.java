package wolf.parser;

import java.io.File;
import java.io.FileNotFoundException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.NoSuchElementException;
import java.util.Scanner;
import java.util.Set;

/**
 *
 * @author Kevin Dittmar
 * @version Mar 15, 2016
 */
public class GrammarParser {
    String filename;
    Set<Nonterminal> nonterminals;
    Set<Terminal> terminals;
    StartSymbol startSymbol;
    EndSymbol endSymbol;
    NonterminalRuleLookupTable nonterminalRuleLookupTable;
    NumberedProductionTable productionTable;
    
    // Terminal lookup table that will help our parser to use
    // tokens generated by SableCC.
    Map<String, Terminal> terminalLookupTable;
    
    private int ruleNumber = 0;
    private List<Terminal> sortedTerminals;
    private List<Nonterminal> sortedNonterminals;
    public GrammarParser(String filename) {
        nonterminalRuleLookupTable = new NonterminalRuleLookupTable();
        productionTable = new NumberedProductionTable();
        nonterminals = new LinkedHashSet<>();
        terminals = new LinkedHashSet<>();
        terminalLookupTable = new HashMap<>();
        this.filename = filename;
    }
    
    public void parse() {
        int lines_to_skip = makeTerminalAndNonterminalSets();
        try{
            Scanner scanner = new Scanner(new File(filename));
            for (; lines_to_skip > 0; lines_to_skip--) {
                scanner.nextLine();
                ruleNumber++;
            }
            // Sort terminals and nonterminals by length to 
            // prevent parsing errors
            sortedTerminals = new ArrayList<>(terminals);
            Collections.sort(sortedTerminals, new Comparator<Terminal>() {
                @Override
                public int compare(Terminal t1, Terminal t2) {
                    return t2.getName().length() - t1.getName().length();
                }
            });
            
            sortedNonterminals = new ArrayList<>(nonterminals);
            Collections.sort(
                sortedNonterminals, 
                new Comparator<Nonterminal>() {
                    @Override
                    public int compare(Nonterminal nt1, Nonterminal nt2) {
                        return nt2.getName().length() - nt1.getName().length();
                    }
                }
            );
            
            while (scanner.hasNextLine()) {
                String next_line = scanner.nextLine();
                addProductionRule(next_line);
            }
        }
        catch (FileNotFoundException e) {
            System.err.println(e.getMessage());
        }
    }
    
    /**
     * This function makes the Terminal and Nonterminal sets to be used
     * by the FSM, ParseTableGenerator, and LRParser
     * @return number of lines to skip to get to grammar
     */
    private int makeTerminalAndNonterminalSets() {
        int lines_to_skip = 0;
        try {
            Scanner scanner = new Scanner(new File(filename));
            /* 
             * Make terminal set from the list of terminals at start of the
             * file.
             */
            boolean more_terminals = true;
            StringBuilder terms_sb = new StringBuilder();
            try {
                while (more_terminals) {
                    String next = scanner.nextLine();
                    if (next.isEmpty() || next.matches("\\s+")) {
                        more_terminals = false;
                    }
                    else {
                        terms_sb.append(" ").append(next);
                    }
                    // We don't want to read the terminals as part of the
                    // grammar productions
                    lines_to_skip++;
                }
                // The start symbol is specified on the line after the 
                // terminals.
                startSymbol = new StartSymbol(scanner.nextLine().trim());
                // A startSymbol is a nonterminal, so add it to the list.
                nonterminals.add(startSymbol);
                // We don't want to read the start symbol as part of the
                // grammar productions.
                lines_to_skip++;
                
                // The end symbol is specified on the line after the start
                // symbol
                endSymbol = new EndSymbol(scanner.nextLine().trim());
                // We don't want to read the end symbol as part of the
                // grammar productions.
                lines_to_skip++;
            }
            catch (NoSuchElementException e) {
                System.err.println(
                    "Terminal list in " + filename + " never ended");
                System.exit(1);
            }
            
            // Add all of the terminals to the set.
            for (String terminal : terms_sb.toString().trim().split("\\s")) {
                Terminal t = new Terminal(terminal);
                terminals.add(t);
                // Build the name-to-token lookup table.
                // SableCC Lexer terminal Tokens begin with a t and have no
                // underscores.
                terminalLookupTable.put("t"+terminal.replaceAll("_", ""), t);
            }
            // Add the end symbol after all of the other terminals so that
            // it appears at the end of the parse table later.
            terminals.add(endSymbol);
            // Make nonterminal set from the rules
            while (scanner.hasNextLine()) {
                String next_nonterminal = scanner.nextLine().split("=", 2)[0];
                nonterminals.add(new Nonterminal(next_nonterminal.trim()));
            }
        }
        catch (FileNotFoundException e) {
            System.err.println(e.getMessage());
        }
        
        return lines_to_skip;
    }
    
    /**
     * Add a production rule to the list
     * @param next_line is the next line of the grammar, where everything
     * after the equals sign is the rule to be added.
     */
    private void addProductionRule(String next_line) {
        String[] next = next_line.split("=", 2);
        Nonterminal rule_nt = new Nonterminal(next[0].trim());
        ArrayList<Symbol> rule_symbols = new ArrayList<>();
        // Remove all whitespace
        String rule_string = next[1].replaceAll("\\s+", "");
        START: while (!rule_string.isEmpty()) {
            if (rule_string.equals(endSymbol.getName())) {
                rule_string = "";
                rule_symbols.add(endSymbol);
            }
            else if (rule_string.matches("[A-Z].*")) {
                for (Nonterminal nt : sortedNonterminals) {
                    if (rule_string.startsWith(nt.getName())) {
                        rule_string = rule_string.replaceFirst(nt.getName(), "");
                        rule_symbols.add(new Nonterminal(nt.getName()));
                        continue START;
                    }
                }
                failedToParse(rule_string);
            }
            else {
                for (Terminal t : sortedTerminals) {
                    if (rule_string.startsWith(t.getName())) {
                        rule_string = 
                            rule_string.substring(t.getName().length());
                        rule_symbols.add(new Terminal(t.getName()));
                        continue START;
                    }
                }
                failedToParse(rule_string);
            }
        }

        Rule rule = new Rule(rule_nt, rule_symbols);
        productionTable.addRule(rule);
        nonterminalRuleLookupTable.add(rule_nt, rule);
        ruleNumber++;
    }
    
    // Didn't match terminals or non-terminals.
    // Print error and exit.
    private void failedToParse(String rule_string) {
        System.err.println(
            "Failed to parse " + ruleNumber + 
            ":" + rule_string + " remaining"
        );
        System.exit(1);  
    }
}